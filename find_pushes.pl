#!/usr/bin/env perl

# A script to identify pushes to gitlab bare repositories, and determine
# which commit was the last commit made before each push. This can be used
# to tag push commits or to analyse push patterns.

use strict;
use v5.14;
use File::Find;
use File::Spec;
use DateTime;
use Data::Dumper;

# Horrible globals, because we need to use find() and there's no way
# to pass arguments into the find callback
my $commits;


## @fn $ get_commits($gitdir, $after)
# Given a git repository, fetch the list of commits. This pulls the list of
# all commits to the git repo after the timestamp provided and parses the
# list into a hash containing:
#
# - commits: A reference to an array of hashrefs, each element contains the
#            commit sha1, timestamp, and message.
# - mapping: A reference to a hash mapping sha1s to entries in the commits
#            list (ie: fast lookup for elements in the commits list)
#
# @param gitdir The directory containing the git repository, assumed to be a
#               bare repo.
# @param after  The date (and optionally time) to fetch commits after; see the
#               man page for git-log.
# @return A reference to a hash containing the commit data.
sub get_commits {
    my $gitdir = shift;
    my $after  = shift;

    my $commits = `/usr/bin/git --git-dir='$gitdir' log --format='%H %ct %s' --all --decorate --reverse --after=$after`;
    my @commitlist = split(/^/, $commits);

    my $result;
    foreach my $commit (@commitlist) {
        my ($sha1, $timestamp, $message) = $commit =~ /^(\S+) (\d+) (.*)$/;

        if($sha1 && $timestamp && $message) {
            my $fields = { sha1      => $sha1,
                           timestamp => $timestamp,
                           message   => $message
            };

            # Store the hash in both useful fashions
            push(@{$result -> {"commits"}}, $fields);
            $result -> {"mapping"} -> {$sha1} = $fields;
        }
    }

    return $result;
}


## @fn void process_object(void)
# Callback function for File::Find::find() that is invoked for each directory
# entry. This assumes that find() has been invoked on the objects database
# inside a git repo, and it pulls out the modified time for each object.
#
# @note This modifies the global $commits hash
sub process_object {
    my $object = $File::Find::name;

    # Skip non-files and packs
    return unless(-f $object);
    return if($object =~ m|/pack/|);

    my ($prefix, $suffix) = $object =~ m|/(\w+)/(\w+)$|;
    my $sha1 = $prefix.$suffix;

    my ($mtime) = (stat($object))[9];
    $commits -> {"mapping"} -> {$sha1} -> {"timestamp"} = $mtime;

    push(@{$commits -> {"times"} -> {$mtime}}, $sha1);
}


## @fn void get_timestamps($gitdir)
# Get the timestamps of all objects in the specified git database.
#
# @param gitdir The git repository.
sub get_timestamps {
    my $gitdir = shift;

    # We're actually interested in the object database
    my $path = File::Spec -> catdir($gitdir, "objects");
    find(\&process_object, $path);
}


## @fn $ find_last_commit($commitdata, $objects)
# Work out which commit in the specified object list is the most recent commit.
#
# @param commitdata A reference to a hash containing the commit data as returned
#                   by get_commits()
# @param objects    A refrence to an array of SHA1s for commits that happened
#                   during a given timestamp
# @retun The SHA1 of the last real commit in the timestamp list of objects.
sub find_last_commit {
    my $commitdata = shift;
    my $objects    = shift;

    my ($lastcommit, $lasttime);
    foreach my $object (@{$objects}) {
        my $commit = $commitdata -> {"mapping"} -> {$object};

        # Is this a real commit? (it might not be - it could be a blob or tree object)
        if($commit) {
            if(!$lastcommit || ($commit -> {"timestamp"} > $lasttime)) {
                $lasttime   = $commit -> {"timestamp"};
                $lastcommit = $commit -> {"sha1"};
            }
        }
    }

    return $lastcommit;
}


## @fn $ find_pushes($commitdata)
# Given commit data generated by get_commits() and timestamps from get_timestamps(),
# work out which commits are the last commit in each push.
#
# @param commitdata A reference to a hash containing the commit data as returned
#                   by get_commits()
#
sub find_pushes {
    my $commitdata = shift;
    my $prefix     = shift;

    # Each of the timestamps should correspond to a push, and it should
    # encompass a number of objects
    foreach my $timestamp (sort keys %{$commitdata -> {"times"}}) {
        my $time = DateTime -> from_epoch(epoch => $timestamp, time_zone => "Europe/London");
        my $lastcommit = find_last_commit($commitdata, $commitdata -> {"times"} -> {$timestamp});
        next unless($lastcommit);

        my $resp = `/usr/bin/git --git-dir='$commitdata->{path}' tag 'SELA/$lastcommit' $lastcommit`;
        print $prefix,",",$time -> strftime("%FT%T%z" ),",","$lastcommit\n";
    }

}


# Repository path is the first argument, the 'from' date is the second
my $reponame = $ARGV[0];
my $after    = $ARGV[1];

# Make sure we're looking at the .git dir (handily will deal with
# bare repos and .git dirs inside a working directory)
$reponame = File::Spec -> catdir($reponame, ".git")
    unless($reponame =~ m|.git/?|);

# Work out the namespage and repository names
my ($namespace, $repository) = $reponame =~ m|/([^/]+)/([^/]+)/?.git$|;
my $prefix = "$namespace,$repository";

# Fetch the list of commits, and the timestamps for objects in the database
$commits = get_commits($reponame, $after);
get_timestamps($reponame);

$commits -> {"path"} = $reponame;
find_pushes($commits, $prefix);
